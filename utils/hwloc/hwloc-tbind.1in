.\" -*- nroff -*-
.\" Copyright © 2009-2018 Inria.  All rights reserved.
.\" Copyright © 2010 Université of Bordeaux
.\" Copyright © 2009-2010 Cisco Systems, Inc.  All rights reserved.
.\" See COPYING in top-level directory.
.TH HWLOC-TBIND "1" "%HWLOC_DATE%" "%PACKAGE_VERSION%" "%PACKAGE_NAME%"
.SH NAME
hwloc-tbind \- Launch a command with threads bound to a single processing unit following a policy or output a list of processing units following a policy.
.
.\" **************************
.\"    Synopsis Section
.\" **************************
.SH SYNOPSIS
.
.B hwloc-tbind
[\fIoptions\fR] \fI[--] <command> \fR...
.
.PP
Note that hwloc(7) provides a detailed explanation of the hwloc system
and of valid topology levels and cpuset formats;
it should be read before reading this man page.
.\" **************************
.\"    Options Section
.\" **************************
.SH OPTIONS
.
.TP
\fB\-h\fR \fB\-\-help\fR 
Display utility help.
.TP
\fB\-i\fR \fB\-\-input\fR <file>
Output a processing unit permutation for a topology provided
as an xml topology file. If not provided, the current system
topology is used.
.TP
\fB\-n\fR \fB\-\-num\fR <integer>
Output a processing unit permutation of at most <integer> elements.
The default behaviour is to output all processing units.
.TP
\fB\-l\fR \fB\-\-logical\fR
Output logical index of topology objects instead of os index.
Default output is using physical (os) indexing.
.TP
\fB\-s\fR \fB\-\-separator\fR <string>
Separate indexes of topology objects in output with a custom separator.
The default separator is a space.
.TP
\fB\-\-shuffle\fR
Shuffle indexes of topology levels when using tleaf policy.
This is used to randomize the output permutation while sticking
to the policy. Works only with tleaf policy.
.TP
\fB\-r\fR \fB\-\-restrict\fR <hwloc_obj_type:logical_index>
Restrict the topology on which permutation is computed
to a topology object cpuset.
.TP
\fB\-r\fR \fB\-\-restrict\fR <cpuset>
Restrict the topology on which permutation is computed
to a cpuset.
.TP
\fB\-p\fR \fB\-\-policy\fR <policy> <policy arg>
Output a permutation of topology objects fulfilling a specific policy.
Available policies are: round-robin, scatter, tleaf.
See POLICIES section for more information on policies and their argument.
.
.\" **************************
.\"    Policies Section
.\" **************************
.SH POLICIES
.
.B round-robin <topology-level>:
The round-robin policy output a single processing unit (PU) per
topology object of type <topology-level> in a round-robin fashion
of <topology-level> logical indexes. If oversubscribing happens,
i.e there are more processing units than objects of type <topology-level>,
children processing unit will be iterated also in a round-robin fashion
at each round of oversubscribing to avoid populating twice the same computing
unit. This policy favors locality between neighbor threads.
.PP
.B scatter <topology-level>:
The scatter policy output a single processing unit (PU) per
topology object of type <topology-level> in a scatter fashion
of <topology-level> logical indexes. Scatter policy output
processing units successively such that they share the least
amount of resources. For instance, the first two processing units
output on a bi-socket system will be on different sockets.
If the system has 4 last level caches (LLC), then the first 4 threads
will be on different LLCs. This policy favors hierarchical resources
exclusivity.
.PP
.B tleaf <topology-level:topology-level:...>:
The tleaf policy is actually a policy builder.
Round-robin and scatter policies can be built from tleaf policy.
A tleaf is a tree where all nodes of a level have the same arity.
Such property is verified in most machines topology. It is still possible to map
a tleaf on a topology which does not have this property by expanding the tleaf
to span the topology and ignore unachievable nodes. tleaf policy is an iterator on
tleaf leaves, i.e the deepest topology object it contains. Each leaf has several
coordinates, one per depth in the tleaf, and coordinates range from 0 to depth's
arity. The way these coordinates are incremented sets the policy on which leaves
are iterated. Coordinates iteration is done from the first provided topology level
to the last topology level. Round robin-policy is typically a tleaf where levels
are stacked from the processing units to the topology root and scatter policy is a
tleaf where levels are stacked in the opposite order. In the round-robin policy,
leaves of a parent node are iterated. Then next parent is looked for and its leaves
are iterated, and so on. Examples of output with tleaf policy are provided in
EXAMPLE section.
.
.\" **************************
.\"    Description Section
.\" **************************
.SH DESCRIPTION
.
hwloc-tbind builds a list of topology objects and bind new threads
in the order of there creation to match cpusets of objects inside this list.
.
.PP
The binding is performed via a ptrace call able to catch clone system call
and perform a binding operation on the caught thread.
This low-level binding makes the utility working on any threading paradigm
based on clone system call such as OpenMP or pthread.
.
.PP
More over when a runtime such as OpenMP has implements its own binding feature,
this utility remains usefull to output the settings to provide to the runtime to
bind threads. See EXAMPLES section.
.
.
.\" **************************
.\"    Examples Section
.\" **************************
.SH EXAMPLES
.PP
hwloc-tbind's operation is best described through several examples.
.
.PP
hwloc-tbind default behaviour is to output os indexes of one processing
unit (PU) per core in a round-robin fashion. If cores contain several hardware
threads, then, on next rounds of cores, it will iterate PUs in a round-robin fashion,
to avoid overlapping the same PUs:

    $ hwloc-affinty

which is exactly equivalent to the following line:

    $ hwloc-tbind -p round-robin core

hwloc-tbind can bind a process threads in the order of their creation
to match the permutation of PUs:

    $ hwloc-tbind -p round-robin core -- echo hello_affinity

hwloc-tbind can be used in conjunction with gcc OpenMP to, for instance,
run an OpenMP application with one thread per core placed in a round-robin
fashion:

    $ export OMP_NUM_THREADS=$(hwloc-calc Machine:0 -N core)
    $ export GOMP_CPU_AFFINITY=$(hwloc-tbind -p round-robin core)

Custom policies can be built with tleaf policy.
For instance round-robin policy on cores is equivalent to:

    $ hwloc-tbind -p tleaf pu:core:machine
    $ hwloc-tbind -p tleaf pu:core

For a machine containing levels: Machine, Socket, L3, L2, L1, Core, PU,
scatter policy on processing units is equivalent to:

    $ hwloc-tbind -p tleaf machine:socket:L3:L2:L1:core:pu

For iterating sockets in a round-robin fashion and scattering threads on sockets PUs:

    $ hwloc-tbind -p tleaf socket:machine:L3:L2:L1:core:pu
.
.\" **************************
.\"    Return value section
.\" **************************
.SH RETURN VALUE
Upon successful execution, hwloc-tbind execs the command over itself.
The return value is therefore whatever the return value of the command
is. If no command is issued, then hwloc-tbind returns 0 on success
and 1 on failure if (not limited to) provided arguments can't lead to
a correct execution.
.
.PP
.\" **************************
.\"    See also section
.\" **************************
.SH SEE ALSO
.
.ft R
hwloc(7), lstopo(1), hwloc-calc(1)
.sp
